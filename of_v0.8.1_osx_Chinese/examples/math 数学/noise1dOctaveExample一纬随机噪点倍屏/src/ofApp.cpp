//disclaimer: some of the functionalities I'm not even certain how to describe in English.  Make sure you understand how ofPushMatrix()/ofPupMatrix() works

//首先熟悉ofPushMatrix() 和 ofPopMatrix() 的功能

/*
 This example demonstrates how more "organic" noise signals
 can be generated by summing multiple "octaves" of noise.
 */

/*
 如何通过一些独立的八音度(Octave)或稱倍頻程去构造一个更"自然“的噪声信号，具体的方式和严厉我也不太清楚，但挺有意思的. 也不是真正的八音度，只不过是一种称呼
 */

#include "ofApp.h"

//--------------------------------------------------------------
// 一切从这里开始
void ofApp::setup(){
    
	// 设置标题，背景颜色，圆圈分辨率， ofSetVerticalSync()-同步更新屏幕重绘和屏幕的垂直刷新
	ofSetWindowTitle("Multiband Noise Example");
	ofSetVerticalSync(true);
	
	setupMultibandNoiseDemo();
}

//--------------------------------------------------------------
void ofApp::update(){
    
	// 每一步从这里启发
	updateMultibandNoiseDemo();
}

//--------------------------------------------------------------
void ofApp::draw(){
    
    // 设置背景颜色，使用圆形渐变性的色彩？没看出来什么反映
	ofBackgroundGradient( ofColor(240), ofColor(180), OF_GRADIENT_CIRCULAR);
	renderMultibandNoiseDemo();
}

//--------------------------------------------------------------
void ofApp::setupMultibandNoiseDemo(){
    
	// setup and allocate resources used in the multi-noise strip demo.
	// 准备八种噪音和相应的滑块
	nNoiseStrips = 8;
	sliderGroup.resize(nNoiseStrips);
	noiseDataStripGroup.resize(nNoiseStrips);
	
    
    // 噪音图形的位置和尺寸和各个之间的空间
	originX = 100;
	originY = 100;
	float stripWidth	= 300;
	float stripHeight	= 35;
	float yMargin		= 5;
	float stripXPos		= originX;
	float stripYPos		= originY;
	float noiseStep		= 0.001;
	
    
	// These are the initial weights of the sliders, which multiply against their respective noise channels.
    // 这些乘积影响它们所代表的噪点频道，是用来计算信号的一个加权分数，算是一种贡献量的分配
	float noiseAmounts[8] = {0,0,0, 0.82,0.59,0.41, 0.06,0.17}; // fer example
	
    
	// I'm using a simple struct ("NoiseDataStrip", in ofApp.h) to store the
	// data contained by one of these noise recordings. Each struct contains
	// the bounding coordinates (x,y,w,h), and some other parameters, plus
	// the float array (data) containing the noise recordings.
	//
    // 用一个结构（“NoiseDataStrip”在ofApp.h）来存储八音度图形的性质（尺寸，位置，时段间隔)， 不知道问什么要乘以2
	for (int i=0; i<nNoiseStrips; i++){
		noiseDataStripGroup[i].x = stripXPos;
		noiseDataStripGroup[i].y = stripYPos;
		noiseDataStripGroup[i].width = stripWidth;
		noiseDataStripGroup[i].height = stripHeight;
		noiseDataStripGroup[i].noiseStep = noiseStep;
		noiseStep *= 2.0;
        
        // 所有都先设置为1
		for (int j=0; j< NOISE_DATA_STRIP_LENGTH; j++){
			noiseDataStripGroup[i].data[j] = 1.0;
		}
		
        // 根据上面的的noiseAmounts来控制鼠标的移动力
		float sliderX = stripXPos+stripWidth+yMargin;
		float sliderAmount = noiseAmounts[i]; //1.0 / (powf(2.0, i));
		sliderGroup[i].setup(sliderX, stripYPos, 16,stripHeight, 0.00, 1.0, sliderAmount, true,true);
		stripYPos += stripHeight + yMargin;
	}
    
}

//--------------------------------------------------------------

void ofApp::updateMultibandNoiseDemo(){
	
	// 第一个循环代表所有的八音度图形
	for (int i=0; i<nNoiseStrips; i++){
		
		// Push the older data to the end of the array
        // 往尾巴移动一步
		float *data = (float *)noiseDataStripGroup[i].data;
		for (int j=(NOISE_DATA_STRIP_LENGTH-1); j>0; j--){
			data[j] = data[j-1];
		}
		
		// Add the most recent data, the noise value. Here's where we actually fetch the noise, using ofNoise().
        // data[1] 到 data[NOISE_DATA_STRIP_LENGTH] 都更新了，最后data[0]用perlin杂来计算，算法不太明白, 只要体现出一定的随机行为
		float noiseStep = noiseDataStripGroup[i].noiseStep;
		float t = (ofGetElapsedTimeMillis()/10.0 + i) * noiseStep;
		data[0] = ofNoise(t);
	}
	
    
	// Compute the normalization factor: the total sum of the weights for all of the contributing noise channels.
    // 因为信号是所有八音度组合的，其中每一个由滑块控制（ofxSimpleSlider in ofApp.h), 先加起所有的份量，最后变成一个百分之百的比例
	float normalizationFactor = 0;
	for (int i=0; i<nNoiseStrips; i++){
		float weight = sliderGroup[i].getValue();
		normalizationFactor += weight;      //这个数字是噪点可以取得的最大值，代表“满分”
	}
    
    
    // 没什么明确的道理
	if (normalizationFactor == 0){
		normalizationFactor = 1.0;
	}
    
	
	// For every sample in the recording history,
    // 这个循环代表 256 个信号的历史
	for (int j=0; j<NOISE_DATA_STRIP_LENGTH; j++){
		float sumj = 0;
		
		// Sum the weighted contribution from each of the noise strips.
        // 总结所有八音度的噪音，必须乘以 weight（它的贡献，我不太清楚为什么要这样，好像是一种加权求和的算法)
		for (int i=0; i<nNoiseStrips; i++){
			float val = noiseDataStripGroup[i].data[j];
			float weight = sliderGroup[i].getValue();
			sumj += (weight * val);
		}
		
		// Normalize it to the range 0...1 by dividing it by normalizationFactor, as we discussed above.
        // 最后重新规范化为0之1的范围
        summedNoiseData[j] = sumj / normalizationFactor;
	}
}


//--------------------------------------------------------------
void ofApp::renderMultibandNoiseDemo(){
	
	// draw the individual strips
    // 画各个八音度图形
	float stackBottom = 0;
	for (int i=0; i<nNoiseStrips; i++){
		float x = noiseDataStripGroup[i].x;
		float y = noiseDataStripGroup[i].y;
		float w = noiseDataStripGroup[i].width;
		float h = noiseDataStripGroup[i].height;
		stackBottom = y+h;
		
		float noiseStep = noiseDataStripGroup[i].noiseStep;
		float *data = (float *) (noiseDataStripGroup[i].data);
		render1DNoiseStrip (x,y, w,h, noiseStep, data);
	}
	
    
	// draw the strip containing the summed data.
    // 画集体的信号
	render1DNoiseStrip(originX, stackBottom+125, 300,100, 0, (float *)summedNoiseData);
	
    
    // 一些简单的解释,大概意思就是最下面的信号是上面的组合
	string multiBandText   = "ofNoise() creates a signal that varies \n";
	multiBandText         += "smoothly between 0 and 1. More 'organic' \n";
	multiBandText         += "noise can be made by adding multiple \n";
	multiBandText         += "'octaves' of noise. The strip below shows \n";
	multiBandText         += "the sum of the above streams, weighted by \n";
	multiBandText         += "the values in their corresponding sliders. \n";
	
    
    // 显示一些有关的数据
	ofSetColor(0,0,0);
	ofDrawBitmapString(multiBandText, originX,   stackBottom+33);
	ofDrawBitmapString("ofNoise()",   originX+1, stackBottom+33); //bold it
	
	ofDrawBitmapString("Noise Step", originX-46, originY-5);
	ofDrawBitmapString("Weights", originX+300+5, originY-5);
}


//--------------------------------------------------------------
// 画最终集合的信号
void ofApp::render1DNoiseStrip (float x, float y, float width, float height, float dt, float *data){
	
    // 禁止平滑，使颜色混合，移动到（x,y,0);
	ofPushMatrix();
	ofDisableSmoothing();
	ofEnableAlphaBlending();
	ofTranslate(x, y, 0);
	
    
	// Yes, this is a drop shadow
    // 画一个阴影
	ofFill();
	ofSetColor(0,0,0, 10);
	ofRect(0,0, width+4, height+2);
	ofRect(0,0, width+2, height+4);
	
    
	// Draw a white box underneath the strip
    // 画一个百盒
	ofFill();
	ofSetColor(255,255,255);
	ofRect(0,0, width, height);
	
    
	// Draw a filled gray noise terrain.
    // 填充线下的区域
	ofEnableSmoothing();
	ofFill();
	ofSetColor(190);
    
    
    // 用 ofBeginShape()/ofEndShape() 循环里的顶点来绘制新的形状，和openGL的格式几乎一样
	ofBeginShape();
	ofVertex(width, height);
	for (int i=0; i<NOISE_DATA_STRIP_LENGTH; i++){
		float px = ofMap(i, 0,(NOISE_DATA_STRIP_LENGTH-1), width,0);
		float py = height * data[i];
		ofVertex(px,py);
	}
	ofVertex(0, height);
	ofEndShape(true);
	
    
	// Draw the black line of the noise waveform
    // 画代表波音的灰线
	ofNoFill();
	ofSetColor(0,0,0);
    
    
    // 信号是由顶点排列形成的
	ofBeginShape();
	for (int i=0; i<NOISE_DATA_STRIP_LENGTH; i++){
		float px = ofMap(i, 0,(NOISE_DATA_STRIP_LENGTH-1), width,0);
		float py = height * data[i];
		ofVertex(px,py);
	}
	ofEndShape(false);
	
    
	// Draw a box outline on top, around everything
    // 画一个保卫信号的大方块
	ofDisableSmoothing();
	ofNoFill();
	ofSetColor(0,0,0);
	ofRect(0,0, width, height);
	
    
	// Draw the dt noise-step factor
    // 在最左边显示各个八音度的贡献量，所有加起来等于一
	if (dt > 0){
		ofSetColor(0,0,0);
		string label = ofToString(dt);
		ofDrawBitmapString(label, -46, height/2+6);
	}
    
    //和最开始的ofPushMatrix()对称
	ofPopMatrix();
}

// In case you're wondering, the simpleSliders get their mouse info through event handlers.
// simpleSliders 直接通过鼠标事件处理程序来获取鼠标信息。
//--------------------------------------------------------------
void ofApp::keyPressed(int key){
    
}

//--------------------------------------------------------------
void ofApp::keyReleased(int key){
    
}

//--------------------------------------------------------------
void ofApp::mouseMoved(int x, int y){
    
}

//--------------------------------------------------------------
void ofApp::mouseDragged(int x, int y, int button){
    
}

//--------------------------------------------------------------
void ofApp::mousePressed(int x, int y, int button){
    
}

//--------------------------------------------------------------
void ofApp::mouseReleased(int x, int y, int button){
    
}

//--------------------------------------------------------------
void ofApp::windowResized(int w, int h){
    
}

//--------------------------------------------------------------
void ofApp::gotMessage(ofMessage msg){
    
}

//--------------------------------------------------------------
void ofApp::dragEvent(ofDragInfo dragInfo){
    
}
